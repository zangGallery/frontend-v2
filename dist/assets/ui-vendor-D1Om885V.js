import{R as z,c as Zo,p as fn}from"./react-vendor-DDjscz8v.js";var Un={};function Yo(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Xo=Yo,D=Xo;function Jo(e){return!!e&&typeof e.then=="function"}var q=Jo;function Qo(e,t){if(e!=null)return e;throw D(t??"Got unexpected null or undefined")}var Y=Qo;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class dt{getValue(){throw D("BaseLoadable")}toPromise(){throw D("BaseLoadable")}valueMaybe(){throw D("BaseLoadable")}valueOrThrow(){throw D(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw D("BaseLoadable")}promiseOrThrow(){throw D(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw D("BaseLoadable")}errorOrThrow(){throw D(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw D("BaseLoadable")}}class er extends dt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return q(n)?Ee(n):Ie(n)?n:Ze(n)}catch(n){return q(n)?Ee(n.next(()=>this.map(t))):ft(n)}}}class tr extends dt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Pn extends dt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Ee(this.contents.then(n=>{const o=t(n);if(Ie(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(q(n))return n.then(()=>this.map(t).contents);throw n}))}}function Ze(e){return Object.freeze(new er(e))}function ft(e){return Object.freeze(new tr(e))}function Ee(e){return Object.freeze(new Pn(e))}function xn(){return Object.freeze(new Pn(new Promise(()=>{})))}function nr(e){return e.every(t=>t.state==="hasValue")?Ze(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?ft(Y(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Ee(Promise.all(e.map(t=>t.contents)))}function On(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Ie(r)?r:q(r)?Ee(r):Ze(r)),o=nr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,u)=>({...a,[s]:r[u]}),{}))}function Ie(e){return e instanceof dt}const or={of:e=>q(e)?Ee(e):Ie(e)?e:Ze(e),error:e=>ft(e),loading:()=>xn(),all:On,isLoadable:Ie};var Ae={loadableWithValue:Ze,loadableWithError:ft,loadableWithPromise:Ee,loadableLoading:xn,loadableAll:On,isLoadable:Ie,RecoilLoadable:or},rr=Ae.loadableWithValue,ar=Ae.loadableWithError,sr=Ae.loadableWithPromise,ir=Ae.loadableLoading,lr=Ae.loadableAll,cr=Ae.isLoadable,ur=Ae.RecoilLoadable,Ye=Object.freeze({__proto__:null,loadableWithValue:rr,loadableWithError:ar,loadableWithPromise:sr,loadableLoading:ir,loadableAll:lr,isLoadable:cr,RecoilLoadable:ur});const Pt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function dr(e,t){var n,o;const r=(n=Un[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw D(`process.env.${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function fr(e,t){var n;const o=(n=Un[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function hr(){var e;typeof fn>"u"||((e=fn)===null||e===void 0?void 0:e.env)!=null&&(dr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Pt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),fr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Pt.RECOIL_GKS_ENABLED.add(n)})}))}hr();var Xe=Pt;function ht(e){return Xe.RECOIL_GKS_ENABLED.has(e)}ht.setPass=e=>{Xe.RECOIL_GKS_ENABLED.add(e)};ht.setFail=e=>{Xe.RECOIL_GKS_ENABLED.delete(e)};ht.clear=()=>{Xe.RECOIL_GKS_ENABLED.clear()};var H=ht;function vr(e,t,{error:n}={}){return null}var pr=vr,ie=pr,Ct,Vt,$t;const _r=(Ct=z.createMutableSource)!==null&&Ct!==void 0?Ct:z.unstable_createMutableSource,Bn=(Vt=z.useMutableSource)!==null&&Vt!==void 0?Vt:z.unstable_useMutableSource,Kt=($t=z.useSyncExternalStore)!==null&&$t!==void 0?$t:z.unstable_useSyncExternalStore;let hn=!1;function mr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,r=((e=t==null?void 0:t.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null;return Kt&&!r&&!hn&&(hn=!0,ie()),r}function yr(){return H("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:H("recoil_sync_external_store")&&Kt!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:H("recoil_mutable_source")&&Bn!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?H("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:H("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}var Gt={createMutableSource:_r,useMutableSource:Bn,useSyncExternalStore:Kt,currentRendererSupportsUseSyncExternalStore:mr,reactMode:yr};class Ht{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class zn extends Ht{}class Fn extends Ht{}function Sr(e){return e instanceof zn||e instanceof Fn}var vt={AbstractRecoilValue:Ht,RecoilState:zn,RecoilValueReadOnly:Fn,isRecoilValue:Sr},gr=vt.AbstractRecoilValue,br=vt.RecoilState,Rr=vt.RecoilValueReadOnly,wr=vt.isRecoilValue,Te=Object.freeze({__proto__:null,AbstractRecoilValue:gr,RecoilState:br,RecoilValueReadOnly:Rr,isRecoilValue:wr});function Er(e,...t){}var Tr=Er,Wn=Tr;function Ar(e,t){return(function*(){let n=0;for(const o of e)yield t(o,n++)})()}var pt=Ar;class Kn{}const Nr=new Kn,Ue=new Map,jt=new Map;function Lr(e){return pt(e,t=>Y(jt.get(t)))}function Cr(e){if(Ue.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function Vr(e){Xe.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&Cr(e.key),Ue.set(e.key,e);const t=e.set==null?new Te.RecoilValueReadOnly(e.key):new Te.RecoilState(e.key);return jt.set(e.key,t),t}class $r extends Error{}function Mr(e){const t=Ue.get(e);if(t==null)throw new $r(`Missing definition for RecoilValue: "${e}""`);return t}function kr(e){return Ue.get(e)}const ct=new Map;function Dr(e){var t;if(!H("recoil_memory_managament_2020"))return;const n=Ue.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ue.delete(e),(o=Gn(e))===null||o===void 0||o(),ct.delete(e)}}function Ir(e,t){H("recoil_memory_managament_2020")&&(t===void 0?ct.delete(e):ct.set(e,t))}function Gn(e){return ct.get(e)}var _e={recoilValues:jt,registerNode:Vr,getNode:Mr,getNodeMaybe:kr,deleteNodeConfigIfPossible:Dr,setConfigDeletionHandler:Ir,getConfigDeletionHandler:Gn,recoilValuesForKeys:Lr,DefaultValue:Kn,DEFAULT_VALUE:Nr};function Ur(e,t){t()}var Pr={enqueueExecution:Ur};function xr(e,t){return t={exports:{}},e(t,t.exports),t.exports}var Or=xr(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(l){return typeof l}:function(l){return l&&typeof Symbol=="function"&&l.constructor===Symbol&&l!==Symbol.prototype?"symbol":typeof l},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,u=r/4,d={},f=function(i){return function(){return i}},v=n.hash=function(l){var i=typeof l>"u"?"undefined":t(l);if(i==="number")return l;i!=="string"&&(l+="");for(var h=0,m=0,y=l.length;m<y;++m){var g=l.charCodeAt(m);h=(h<<5)-h+g|0}return h},S=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},k=function(i,h){return h>>>i&a},T=function(i){return 1<<i},E=function(i,h){return S(i&h-1)},V=function(i,h,m,y){var g=y;if(!i){var L=y.length;g=new Array(L);for(var A=0;A<L;++A)g[A]=y[A]}return g[h]=m,g},Q=function(i,h,m){var y=m.length-1,g=0,L=0,A=m;if(i)g=L=h;else for(A=new Array(y);g<h;)A[L++]=m[g++];for(++g;g<=y;)A[L++]=m[g++];return i&&(A.length=y),A},X=function(i,h,m,y){var g=y.length;if(i){for(var L=g;L>=h;)y[L--]=y[L];return y[h]=m,y}for(var A=0,N=0,U=new Array(g+1);A<h;)U[N++]=y[A++];for(U[h]=m;A<g;)U[++N]=y[A++];return U},w=1,C=2,x=3,F=4,K={__hamt_isEmpty:!0},G=function(i){return i===K||i&&i.__hamt_isEmpty},re=function(i,h,m,y){return{type:w,edit:i,hash:h,key:m,value:y,_modify:Ve}},ye=function(i,h,m){return{type:C,edit:i,hash:h,children:m,_modify:$e}},ee=function(i,h,m){return{type:x,edit:i,mask:h,children:m,_modify:P}},ue=function(i,h,m){return{type:F,edit:i,size:h,children:m,_modify:W}},Ce=function(i){return i===K||i.type===w||i.type===C},J=function(i,h,m,y,g){for(var L=[],A=y,N=0,U=0;A;++U)A&1&&(L[U]=g[N++]),A>>>=1;return L[h]=m,ue(i,N+1,L)},le=function(i,h,m,y){for(var g=new Array(h-1),L=0,A=0,N=0,U=y.length;N<U;++N)if(N!==m){var Z=y[N];Z&&!G(Z)&&(g[L++]=Z,A|=1<<N)}return ee(i,A,g)},Re=function l(i,h,m,y,g,L){if(m===g)return ye(i,m,[L,y]);var A=k(h,m),N=k(h,g);return ee(i,T(A)|T(N),A===N?[l(i,h+o,m,y,g,L)]:A<N?[y,L]:[L,y])},de=function(i,h,m,y,g,L,A,N){for(var U=g.length,Z=0;Z<U;++Z){var se=g[Z];if(m(A,se.key)){var oe=se.value,fe=L(oe);return fe===oe?g:fe===d?(--N.value,Q(i,Z,g)):V(i,Z,re(h,y,A,fe),g)}}var he=L();return he===d?g:(++N.value,V(i,U,re(h,y,A,he),g))},Se=function(i,h){return i===h.edit},Ve=function(i,h,m,y,g,L,A){if(h(L,this.key)){var N=y(this.value);return N===this.value?this:N===d?(--A.value,K):Se(i,this)?(this.value=N,this):re(i,g,L,N)}var U=y();return U===d?this:(++A.value,Re(i,m,this.hash,this,g,re(i,g,L,U)))},$e=function(i,h,m,y,g,L,A){if(g===this.hash){var N=Se(i,this),U=de(N,i,h,this.hash,this.children,y,L,A);return U===this.children?this:U.length>1?ye(i,this.hash,U):U[0]}var Z=y();return Z===d?this:(++A.value,Re(i,m,this.hash,this,g,re(i,g,L,Z)))},P=function(i,h,m,y,g,L,A){var N=this.mask,U=this.children,Z=k(m,g),se=T(Z),oe=E(N,se),fe=N&se,he=fe?U[oe]:K,Me=he._modify(i,h,m+o,y,g,L,A);if(he===Me)return this;var nt=Se(i,this),Oe=N,Be=void 0;if(fe&&G(Me)){if(Oe&=~se,!Oe)return K;if(U.length<=2&&Ce(U[oe^1]))return U[oe^1];Be=Q(nt,oe,U)}else if(!fe&&!G(Me)){if(U.length>=s)return J(i,Z,Me,N,U);Oe|=se,Be=X(nt,oe,Me,U)}else Be=V(nt,oe,Me,U);return nt?(this.mask=Oe,this.children=Be,this):ee(i,Oe,Be)},W=function(i,h,m,y,g,L,A){var N=this.size,U=this.children,Z=k(m,g),se=U[Z],oe=(se||K)._modify(i,h,m+o,y,g,L,A);if(se===oe)return this;var fe=Se(i,this),he=void 0;if(G(se)&&!G(oe))++N,he=V(fe,Z,oe,U);else if(!G(se)&&G(oe)){if(--N,N<=u)return le(i,N,Z,U);he=V(fe,Z,K,U)}else he=V(fe,Z,oe,U);return fe?(this.size=N,this.children=he,this):ue(i,N,he)};K._modify=function(l,i,h,m,y,g,L){var A=m();return A===d?K:(++L.value,re(l,y,g,A))};function c(l,i,h,m,y){this._editable=l,this._edit=i,this._config=h,this._root=m,this._size=y}c.prototype.setTree=function(l,i){return this._editable?(this._root=l,this._size=i,this):l===this._root?this:new c(this._editable,this._edit,this._config,l,i)};var p=n.tryGetHash=function(l,i,h,m){for(var y=m._root,g=0,L=m._config.keyEq;;)switch(y.type){case w:return L(h,y.key)?y.value:l;case C:{if(i===y.hash)for(var A=y.children,N=0,U=A.length;N<U;++N){var Z=A[N];if(L(h,Z.key))return Z.value}return l}case x:{var se=k(g,i),oe=T(se);if(y.mask&oe){y=y.children[E(y.mask,oe)],g+=o;break}return l}case F:{if(y=y.children[k(g,i)],y){g+=o;break}return l}default:return l}};c.prototype.tryGetHash=function(l,i,h){return p(l,i,h,this)};var _=n.tryGet=function(l,i,h){return p(l,h._config.hash(i),i,h)};c.prototype.tryGet=function(l,i){return _(l,i,this)};var $=n.getHash=function(l,i,h){return p(void 0,l,i,h)};c.prototype.getHash=function(l,i){return $(l,i,this)},n.get=function(l,i){return p(void 0,i._config.hash(l),l,i)},c.prototype.get=function(l,i){return _(i,l,this)};var b=n.has=function(l,i,h){return p(d,l,i,h)!==d};c.prototype.hasHash=function(l,i){return b(l,i,this)};var I=n.has=function(l,i){return b(i._config.hash(l),l,i)};c.prototype.has=function(l){return I(l,this)};var R=function(i,h){return i===h};n.make=function(l){return new c(0,0,{keyEq:l&&l.keyEq||R,hash:l&&l.hash||v},K,0)},n.empty=n.make();var O=n.isEmpty=function(l){return l&&!!G(l._root)};c.prototype.isEmpty=function(){return O(this)};var j=n.modifyHash=function(l,i,h,m){var y={value:m._size},g=m._root._modify(m._editable?m._edit:NaN,m._config.keyEq,0,l,i,h,y);return m.setTree(g,y.value)};c.prototype.modifyHash=function(l,i,h){return j(h,l,i,this)};var te=n.modify=function(l,i,h){return j(l,h._config.hash(i),i,h)};c.prototype.modify=function(l,i){return te(i,l,this)};var B=n.setHash=function(l,i,h,m){return j(f(h),l,i,m)};c.prototype.setHash=function(l,i,h){return B(l,i,h,this)};var ne=n.set=function(l,i,h){return B(h._config.hash(l),l,i,h)};c.prototype.set=function(l,i){return ne(l,i,this)};var me=f(d),ce=n.removeHash=function(l,i,h){return j(me,l,i,h)};c.prototype.removeHash=c.prototype.deleteHash=function(l,i){return ce(l,i,this)};var ae=n.remove=function(l,i){return ce(i._config.hash(l),l,i)};c.prototype.remove=c.prototype.delete=function(l){return ae(l,this)};var tt=n.beginMutation=function(l){return new c(l._editable+1,l._edit+1,l._config,l._root,l._size)};c.prototype.beginMutation=function(){return tt(this)};var ln=n.endMutation=function(l){return l._editable=l._editable&&l._editable-1,l};c.prototype.endMutation=function(){return ln(this)};var Oo=n.mutate=function(l,i){var h=tt(i);return l(h),ln(h)};c.prototype.mutate=function(l){return Oo(l,this)};var At=function(i){return i&&cn(i[0],i[1],i[2],i[3],i[4])},cn=function(i,h,m,y,g){for(;m<i;){var L=h[m++];if(L&&!G(L))return un(L,y,[i,h,m,y,g])}return At(g)},un=function(i,h,m){switch(i.type){case w:return{value:h(i),rest:m};case C:case F:case x:var y=i.children;return cn(y.length,y,0,h,m);default:return At(m)}},Bo={done:!0};function Nt(l){this.v=l}Nt.prototype.next=function(){if(!this.v)return Bo;var l=this.v;return this.v=At(l.rest),l},Nt.prototype[Symbol.iterator]=function(){return this};var Lt=function(i,h){return new Nt(un(i._root,h))},zo=function(i){return[i.key,i.value]},Fo=n.entries=function(l){return Lt(l,zo)};c.prototype.entries=c.prototype[Symbol.iterator]=function(){return Fo(this)};var Wo=function(i){return i.key},Ko=n.keys=function(l){return Lt(l,Wo)};c.prototype.keys=function(){return Ko(this)};var Go=function(i){return i.value},Ho=n.values=c.prototype.values=function(l){return Lt(l,Go)};c.prototype.values=function(){return Ho(this)};var dn=n.fold=function(l,i,h){var m=h._root;if(m.type===w)return l(i,m.value,m.key);for(var y=[m.children],g=void 0;g=y.pop();)for(var L=0,A=g.length;L<A;){var N=g[L++];N&&N.type&&(N.type===w?i=l(i,N.value,N.key):y.push(N.children))}return i};c.prototype.fold=function(l,i){return dn(l,i,this)};var jo=n.forEach=function(l,i){return dn(function(h,m,y){return l(m,y,i)},null,i)};c.prototype.forEach=function(l){return jo(l,this)};var qo=n.count=function(l){return l._size};c.prototype.count=function(){return qo(this)},Object.defineProperty(c.prototype,"size",{get:c.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class Br{constructor(t){M(this,"_map",void 0),this._map=new Map(t==null?void 0:t.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return Zt(this)}toMap(){return new Map(this._map)}}class qt{constructor(t){if(M(this,"_hamt",Or.empty.beginMutation()),t instanceof qt){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return Zt(this)}toMap(){return new Map(this._hamt)}}function Zt(e){return H("recoil_hamt_2020")?new qt(e):new Br(e)}var zr={persistentMap:Zt},Fr=zr.persistentMap,Wr=Object.freeze({__proto__:null,persistentMap:Fr});function Kr(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var vn=Kr;function Gr(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var pn=Gr;function Hr(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function jr(e){return{nodeDeps:pn(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:pn(e.nodeToNodeSubscriptions,t=>new Set(t))}}function Mt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const u=s==null?t:vn(t,s);for(const d of u)a.has(d)||a.set(d,new Set),Y(a.get(d)).add(e);if(s){const d=vn(s,t);for(const f of d){if(!a.has(f))return;const v=Y(a.get(f));v.delete(e),v.size===0&&a.delete(f)}}}function qr(e,t,n,o){var r,a,s,u;const d=n.getState();o===d.currentTree.version||o===((r=d.nextTree)===null||r===void 0?void 0:r.version)||o===((a=d.previousTree)===null||a===void 0?void 0:a.version)||ie();const f=n.getGraph(o);if(Mt(e,t,f),o===((s=d.previousTree)===null||s===void 0?void 0:s.version)){const S=n.getGraph(d.currentTree.version);Mt(e,t,S,f)}if(o===((u=d.previousTree)===null||u===void 0?void 0:u.version)||o===d.currentTree.version){var v;const S=(v=d.nextTree)===null||v===void 0?void 0:v.version;if(S!==void 0){const k=n.getGraph(S);Mt(e,t,k,f)}}}var Je={cloneGraph:jr,graph:Hr,saveDepsToStore:qr};let Zr=0;const Yr=()=>Zr++;let Xr=0;const Jr=()=>Xr++;let Qr=0;const ea=()=>Qr++;var _t={getNextTreeStateVersion:Yr,getNextStoreID:Jr,getNextComponentID:ea};const{persistentMap:_n}=Wr,{graph:ta}=Je,{getNextTreeStateVersion:Hn}=_t;function na(){const e=Hn();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:_n(),nonvalidatedAtoms:_n()}}function oa(){const e=na();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,ta()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var jn={makeEmptyStoreState:oa,getNextTreeStateVersion:Hn};class ra{}var Yt={RetentionZone:ra};function aa(e,t){const n=new Set(e);return n.add(t),n}var sa={setByAddingToSet:aa};function*ia(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var Xt=ia;function la(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var qn=la;const{getNode:Qe,getNodeMaybe:ca,recoilValuesForKeys:mn}=_e,{RetentionZone:yn}=Yt,{setByAddingToSet:ua}=sa,da=Object.freeze(new Set);class fa extends Error{}function ha(e,t,n){if(!H("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof yn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!H("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(u){const d=a.nodesRetainedByZone.get(u);d==null||d.delete(t),d&&d.size===0&&a.nodesRetainedByZone.delete(u)}if(n instanceof yn)s(n);else if(Array.isArray(n))for(const u of n)s(u)}}function Jt(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Qe(n),s=ha(e,n,a.retainedBy),u=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{u(),s()})}function va(e,t,n){Jt(e,e.getState().currentTree,t,n)}function pa(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function _a(e,t,n){return Jt(e,t,n,"get"),Qe(n).get(e,t)}function Zn(e,t,n){return Qe(n).peek(e,t)}function ma(e,t,n){var o;const r=ca(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:ua(e.dirtyAtoms,t)}}function ya(e,t,n,o){const r=Qe(n);if(r.set==null)throw new fa(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Jt(e,t,n,"set"),a(e,t,o)}function Sa(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Qe(n).nodeType;return qn({type:a},{loadable:()=>Zn(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return mn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,u;return{nodes:mn(Xt(Yn(e,t,new Set([n])),d=>d!==n)),components:pt((s=(u=o.nodeToComponentSubscriptions.get(n))===null||u===void 0?void 0:u.values())!==null&&s!==void 0?s:[],([d])=>({name:d}))}}})}function Yn(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let u=r.pop();u;u=r.pop()){var s;o.add(u);const d=(s=a.nodeToNodeSubscriptions.get(u))!==null&&s!==void 0?s:da;for(const f of d)o.has(f)||r.push(f)}return o}var Ne={getNodeLoadable:_a,peekNodeLoadable:Zn,setNodeValue:ya,initializeNode:va,cleanUpNode:pa,setUnvalidatedAtomValue_DEPRECATED:ma,peekNodeInfo:Sa,getDownstreamNodes:Yn};let Xn=null;function ga(e){Xn=e}function ba(){var e;(e=Xn)===null||e===void 0||e()}var Jn={setInvalidateMemoizedSnapshot:ga,invalidateMemoizedSnapshot:ba};const{getDownstreamNodes:Ra,getNodeLoadable:Qn,setNodeValue:wa}=Ne,{getNextComponentID:Ea}=_t,{getNode:Ta,getNodeMaybe:eo}=_e,{DefaultValue:Qt}=_e,{reactMode:Aa}=Gt,{AbstractRecoilValue:Na,RecoilState:_c,RecoilValueReadOnly:mc,isRecoilValue:yc}=Te,{invalidateMemoizedSnapshot:La}=Jn;function Ca(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||n.version===((r=a.previousTree)===null||r===void 0?void 0:r.version)||ie();const s=Qn(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function Va(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof Qt?n.delete(r):n.set(r,o)}),n}function $a(e,t,{key:n},o){if(typeof o=="function"){const r=Qn(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw ie(),D(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function Ma(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=$a(e,t,r,a),u=wa(e,t,r.key,s);for(const[d,f]of u.entries())xt(t,d,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;xt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=eo(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else ie(`Unknown action ${n.type}`)}function xt(e,t,n){n.state==="hasValue"&&n.contents instanceof Qt?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function to(e,t){e.replaceState(n=>{const o=no(n);for(const r of t)Ma(e,o,r);return oo(e,o),La(),o})}function mt(e,t){if(je.length){const n=je[je.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else to(e,[t])}const je=[];function ka(){const e=new Map;return je.push(e),()=>{for(const[n,o]of e)to(n,o);je.pop()!==e&&ie()}}function no(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function oo(e,t){const n=Ra(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=eo(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function ro(e,t,n){mt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function Da(e,t,n){if(n instanceof Qt)return ro(e,t,n);mt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function Ia(e,t){mt(e,{type:"markModified",recoilValue:t})}function Ua(e,t,n){mt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Pa(e,{key:t},n,o=null){const r=Ea(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Y(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=Aa();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const u=e.getState().nextTree;u&&u.dirtyAtoms.has(t)&&n(u)}return{release:()=>{const u=e.getState(),d=u.nodeToComponentSubscriptions.get(t);if(d===void 0||!d.has(r)){ie();return}d.delete(r),d.size===0&&u.nodeToComponentSubscriptions.delete(t)}}}function xa(e,t){var n;const{currentTree:o}=e.getState(),r=Ta(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var ge={AbstractRecoilValue:Na,getRecoilValueAsLoadable:Ca,setRecoilValue:ro,setRecoilValueLoadable:Da,markRecoilValueModified:Ia,setUnvalidatedRecoilValue:Ua,subscribeToRecoilValue:Pa,applyAtomValueWrites:Va,batchStart:ka,writeLoadableToTreeState:xt,invalidateDownstreams:oo,copyTreeState:no,refreshRecoilValue:xa};function Oa(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var Ba=Oa;const{cleanUpNode:za}=Ne,{deleteNodeConfigIfPossible:Fa,getNode:ao}=_e,{RetentionZone:so}=Yt,Wa=12e4,io=new Set;function lo(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree){ie();return}const r=new Set;for(const s of t)if(s instanceof so)for(const u of ja(n,s))r.add(u);else r.add(s);const a=Ka(e,r);for(const s of a)Ha(e,o,s)}function Ka(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return u(t),a;function u(d){const f=new Set,v=Ga(e,o,d,a,s);for(const E of v){var S;if(ao(E).retainedBy==="recoilRoot"){s.add(E);continue}if(((S=n.retention.referenceCounts.get(E))!==null&&S!==void 0?S:0)>0){s.add(E);continue}if(co(E).some(Q=>n.retention.referenceCounts.get(Q))){s.add(E);continue}const V=r.nodeToNodeSubscriptions.get(E);if(V&&Ba(V,Q=>s.has(Q))){s.add(E);continue}a.add(E),f.add(E)}const k=new Set;for(const E of f)for(const V of(T=r.nodeDeps.get(E))!==null&&T!==void 0?T:io){var T;a.has(V)||k.add(V)}k.size&&u(k)}}function Ga(e,t,n,o,r){const a=e.getGraph(t.version),s=[],u=new Set;for(;n.size>0;)d(Y(n.values().next().value));return s;function d(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(u.has(f))return;const v=a.nodeToNodeSubscriptions.get(f);if(v)for(const S of v)d(S);u.add(f),n.delete(f),s.push(f)}}function Ha(e,t,n){if(!H("recoil_memory_managament_2020"))return;za(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=co(n);for(const d of r){var a;(a=o.retention.nodesRetainedByZone.get(d))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const d=s.nodeDeps.get(n);if(d!==void 0){s.nodeDeps.delete(n);for(const f of d){var u;(u=s.nodeToNodeSubscriptions.get(f))===null||u===void 0||u.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}Fa(n)}function ja(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:io}function co(e){const t=ao(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof so?[t]:t}function qa(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):lo(e,new Set([t]))}function Za(e,t,n){var o;if(!H("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Ya(e,t):r.set(t,a)}function Ya(e,t){if(!H("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),qa(e,t)}function Xa(e){if(!H("recoil_memory_managament_2020"))return;const t=e.getState();lo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function Ja(e){return e===void 0?"recoilRoot":e}var Pe={SUSPENSE_TIMEOUT_MS:Wa,updateRetainCount:Za,releaseScheduledRetainablesNow:Xa,retainedByOptionWithDefault:Ja};const{unstable_batchedUpdates:Qa}=Zo;var es={unstable_batchedUpdates:Qa};const{unstable_batchedUpdates:ts}=es;var ns={unstable_batchedUpdates:ts};const{batchStart:os}=ge,{unstable_batchedUpdates:rs}=ns;let as=rs||(e=>e());const ss=e=>{as(()=>{let t=()=>{};try{t=os(),e()}finally{t()}})};var en={batchUpdates:ss};function*is(e){for(const t of e)for(const n of t)yield n}var uo=is;const ls=typeof Window>"u"||typeof window>"u";var tn={isSSR:ls};function cs(e,t){let n,o;return[(...s)=>{const u=t(...s);return n===u||(n=u,o=e(...s)),o},()=>{n=null}]}var us={memoizeOneWithArgsHashAndInvalidation:cs};const{batchUpdates:Ot}=en,{initializeNode:ds,peekNodeInfo:fs}=Ne,{graph:hs}=Je,{getNextStoreID:vs}=_t,{DEFAULT_VALUE:ps,recoilValues:Sn,recoilValuesForKeys:gn}=_e,{AbstractRecoilValue:_s,getRecoilValueAsLoadable:ms,setRecoilValue:bn,setUnvalidatedRecoilValue:ys}=ge,{updateRetainCount:lt}=Pe,{setInvalidateMemoizedSnapshot:Ss}=Jn,{getNextTreeStateVersion:gs,makeEmptyStoreState:bs}=jn,{isSSR:Rs}=tn,{memoizeOneWithArgsHashAndInvalidation:ws}=us;class yt{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ms(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),(o==null?void 0:o.isModified)===!0){if((o==null?void 0:o.isInitialized)===!1)return[];const s=this._store.getState().currentTree;return gn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return(o==null?void 0:o.isInitialized)==null?Sn.values():o.isInitialized===!0?gn(uo([r,a])):Xt(Sn.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),fs(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new Bt(this,Ot);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new Bt(this,Ot);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:vs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return Y(r.get(o));const a=hs();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw D("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)ds(this._store,o,"get"),lt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&ie(),this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){Rs||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!H("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){H("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function fo(e,t,n=!1){const o=e.getState(),r=n?gs():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(pt(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function Es(e){const t=new yt(bs());return e!=null?t.map(e):t}const[Rn,ho]=ws((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:Y(o.previousTree);return new yt(fo(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});Ss(ho);function Ts(e,t="latest"){const n=Rn(e,t);return n.isRetained()?n:(ho(),Rn(e,t))}class Bt extends yt{constructor(t,n){super(fo(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{lt(a,o.key,1),bn(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{lt(r,o.key,1),bn(this.getStore_INTERNAL(),o,ps)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();Ot(()=>{for(const[a,s]of o.entries())lt(r,a,1),ys(r,new _s(a),s)})}),this._batch=n}}var St={Snapshot:yt,MutableSnapshot:Bt,freshSnapshot:Es,cloneSnapshot:Ts},As=St.Snapshot,Ns=St.MutableSnapshot,Ls=St.freshSnapshot,Cs=St.cloneSnapshot,gt=Object.freeze({__proto__:null,Snapshot:As,MutableSnapshot:Ns,freshSnapshot:Ls,cloneSnapshot:Cs});function Vs(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var $s=Vs;const{useRef:Ms}=z;function ks(e){const t=Ms(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var wn=ks;const{getNextTreeStateVersion:Ds,makeEmptyStoreState:vo}=jn,{cleanUpNode:Is,getDownstreamNodes:Us,initializeNode:Ps,setNodeValue:xs,setUnvalidatedAtomValue_DEPRECATED:Os}=Ne,{graph:Bs}=Je,{cloneGraph:zs}=Je,{getNextStoreID:po}=_t,{createMutableSource:kt,reactMode:_o}=Gt,{applyAtomValueWrites:Fs}=ge,{releaseScheduledRetainablesNow:mo}=Pe,{freshSnapshot:Ws}=gt,{useCallback:Ks,useContext:yo,useEffect:zt,useMemo:Gs,useRef:Hs,useState:js}=z;function ze(){throw D("This component must be used inside a <RecoilRoot> component.")}const So=Object.freeze({storeID:po(),getState:ze,replaceState:ze,getGraph:ze,subscribeToTransactions:ze,addTransactionMetadata:ze});let Ft=!1;function En(e){if(Ft)throw D("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){H("recoil_memory_managament_2020")&&H("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&mo(e);const n=t.currentTree.version,o=Ds();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,zs(Y(t.graphsByVersion.get(n))))}}const go=z.createContext({current:So}),nn=()=>yo(go),bo=z.createContext(null);function qs(){const e=yo(bo);return e==null&&Wn(),e}function Ro(e,t,n){const o=Us(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[u,d]]of a)d(n)}}function Zs(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,u]of a)u(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!_o().early||t.suspendedComponentResolvers.size>0)&&(Ro(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Ys(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Zs(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):ie("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,H("recoil_memory_managament_2020")&&n==null&&mo(e)}finally{t.commitDepth--}}function Xs({setNotifyBatcherOfChange:e}){const t=nn(),[,n]=js([]);return e(()=>n({})),zt(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),zt(()=>{Pr.enqueueExecution("Batcher",()=>{Ys(t.current)})}),null}function Js(e,t){const n=vo();return t({set:(o,r)=>{const a=n.currentTree,s=xs(e,a,o.key,r),u=new Set(s.keys()),d=a.nonvalidatedAtoms.clone();for(const f of u)d.delete(f);n.currentTree={...a,dirtyAtoms:$s(a.dirtyAtoms,u),atomValues:Fs(a.atomValues,s),nonvalidatedAtoms:d}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=Os(n.currentTree,a,r)})}}),n}function Qs(e){const t=Ws(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Tn=0;function ei({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=T=>{const E=r.current.graphsByVersion;if(E.has(T))return Y(E.get(T));const V=Bs();return E.set(T,V),V},s=(T,E)=>{if(E==null){const{transactionSubscriptions:V}=S.current.getState(),Q=Tn++;return V.set(Q,T),{release:()=>{V.delete(Q)}}}else{const{nodeTransactionSubscriptions:V}=S.current.getState();V.has(E)||V.set(E,new Map);const Q=Tn++;return Y(V.get(E)).set(Q,T),{release:()=>{const X=V.get(E);X&&(X.delete(Q),X.size===0&&V.delete(E))}}}},u=T=>{En(S.current);for(const E of Object.keys(T))Y(S.current.getState().nextTree).transactionMetadata[E]=T[E]},d=T=>{En(S.current);const E=Y(r.current.nextTree);let V;try{Ft=!0,V=T(E)}finally{Ft=!1}V!==E&&(r.current.nextTree=V,_o().early&&Ro(S.current,r.current,V),Y(f.current)())},f=Hs(null),v=Ks(T=>{f.current=T},[f]),S=wn(()=>n??{storeID:po(),getState:()=>r.current,replaceState:d,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:u});n!=null&&(S.current=n),r=wn(()=>e!=null?Js(S.current,e):t!=null?Qs(t):vo());const k=Gs(()=>kt==null?void 0:kt(r,()=>r.current.currentTree.version),[r]);return zt(()=>{const T=S.current;for(const E of new Set(T.getState().knownAtoms))Ps(T,E,"get");return()=>{for(const E of T.getState().knownAtoms)Is(T,E)}},[S]),z.createElement(go.Provider,{value:S},z.createElement(bo.Provider,{value:k},z.createElement(Xs,{setNotifyBatcherOfChange:v}),o))}function ti(e){const{override:t,...n}=e,o=nn();return t===!1&&o.current!==So?e.children:z.createElement(ei,n)}var on={RecoilRoot:ti,useStoreRef:nn,useRecoilMutableSource:qs};function ni(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var oi=ni;const{useEffect:ri,useRef:ai}=z;function si(e){const t=ai();return ri(()=>{t.current=e}),t.current}var ii=si;const{useStoreRef:li}=on,{SUSPENSE_TIMEOUT_MS:ci}=Pe,{updateRetainCount:Fe}=Pe,{RetentionZone:ui}=Yt,{useEffect:di,useRef:fi}=z,{isSSR:An}=tn;function hi(e){if(H("recoil_memory_managament_2020"))return vi(e)}function vi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof ui?s:s.key),o=li();di(()=>{if(!H("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!An)window.clearTimeout(r.current),r.current=null;else for(const u of n)Fe(s,u,1);return()=>{for(const u of n)Fe(s,u,-1)}},[o,...n]);const r=fi(),a=ii(n);if(!An&&(a===void 0||!oi(a,n))){const s=o.current;for(const u of n)Fe(s,u,1);if(a)for(const u of a)Fe(s,u,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const u of n)Fe(s,u,-1)},ci)}}var pi=hi;function _i(){return"<component name not available>"}var bt=_i;const{currentRendererSupportsUseSyncExternalStore:mi,reactMode:et,useMutableSource:yi,useSyncExternalStore:Si}=Gt,{useRecoilMutableSource:gi,useStoreRef:xe}=on,{isRecoilValue:Sc}=Te,{getRecoilValueAsLoadable:Rt,setRecoilValue:bi,subscribeToRecoilValue:wt}=ge,{useCallback:pe,useEffect:ut,useMemo:Ri,useRef:wo,useState:Eo}=z,{isSSR:wi}=tn;function Ei(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),wi&&q(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:D(`Invalid value of loadable atom "${t.key}"`)}function Ti(e){const t=xe(),n=bt(),o=pe(()=>{var u;const d=t.current,f=d.getState(),v=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return{loadable:Rt(d,e,v),key:e.key}},[t,e]),r=pe(u=>{let d;return()=>{var f,v;const S=u();return(f=d)!==null&&f!==void 0&&f.loadable.is(S.loadable)&&((v=d)===null||v===void 0?void 0:v.key)===S.key?d:(d=S,S)}},[]),a=Ri(()=>r(o),[o,r]),s=pe(u=>{const d=t.current;return wt(d,e,u,n).release},[t,e,n]);return Si(s,a,a).loadable}function Ai(e){const t=xe(),n=pe(()=>{var f;const v=t.current,S=v.getState(),k=et().early&&(f=S.nextTree)!==null&&f!==void 0?f:S.currentTree;return Rt(v,e,k)},[t,e]),o=pe(()=>n(),[n]),r=bt(),a=pe((f,v)=>{const S=t.current;return wt(S,e,()=>{if(!H("recoil_suppress_rerender_in_callback"))return v();const T=n();d.current.is(T)||v(),d.current=T},r).release},[t,e,r,n]),s=gi();if(s==null)throw D("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=yi(s,o,a),d=wo(u);return ut(()=>{d.current=u}),u}function Nn(e){const t=xe(),n=bt(),o=pe(()=>{var d;const f=t.current,v=f.getState(),S=et().early&&(d=v.nextTree)!==null&&d!==void 0?d:v.currentTree;return Rt(f,e,S)},[t,e]),r=pe(()=>({loadable:o(),key:e.key}),[o,e.key]),a=pe(d=>{const f=r();return d.loadable.is(f.loadable)&&d.key===f.key?d:f},[r]);ut(()=>{const d=wt(t.current,e,f=>{u(a)},n);return u(a),d.release},[n,e,t,a]);const[s,u]=Eo(r);return s.key!==e.key?r().loadable:s.loadable}function Ni(e){const t=xe(),[,n]=Eo([]),o=bt(),r=pe(()=>{var u;const d=t.current,f=d.getState(),v=et().early&&(u=f.nextTree)!==null&&u!==void 0?u:f.currentTree;return Rt(d,e,v)},[t,e]),a=r(),s=wo(a);return ut(()=>{s.current=a}),ut(()=>{const u=t.current,d=u.getState(),f=wt(u,e,S=>{var k;if(!H("recoil_suppress_rerender_in_callback"))return n([]);const T=r();(k=s.current)!==null&&k!==void 0&&k.is(T)||n(T),s.current=T},o);if(d.nextTree)u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var v;if(!H("recoil_suppress_rerender_in_callback"))return n([]);const S=r();(v=s.current)!==null&&v!==void 0&&v.is(S)||n(S),s.current=S}return f.release},[o,r,e,t]),a}function Li(e){return H("recoil_memory_managament_2020")&&pi(e),{TRANSITION_SUPPORT:Nn,SYNC_EXTERNAL_STORE:mi()?Ti:Nn,MUTABLE_SOURCE:Ai,LEGACY:Ni}[et().mode](e)}function Ci(e){const t=xe(),n=Li(e);return Ei(n,e,t)}function Vi(e){const t=xe();return pe(n=>{bi(t.current,e,n)},[t,e])}function $i(e){return[Ci(e),Vi(e)]}var Mi={useRecoilState:$i};const{batchUpdates:ki}=en,{DEFAULT_VALUE:Di,getNode:Ii}=_e,{AbstractRecoilValue:Ui,setRecoilValueLoadable:Pi}=ge,{cloneSnapshot:gc}=gt,{useCallback:bc,useEffect:Rc,useRef:wc,useState:Ec}=z;function xi(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;ki(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const v of f){var u,d;((u=r.atomValues.get(v))===null||u===void 0?void 0:u.contents)!==((d=a.atomValues.get(v))===null||d===void 0?void 0:d.contents)&&Ii(v).shouldRestoreFromSnapshots&&s.add(v)}s.forEach(f=>{Pi(e,new Ui(f),a.atomValues.has(f)?Y(a.atomValues.get(f)):Di)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}var Oi={gotoSnapshot:xi};const{useMemo:Tc}=z,{loadableWithValue:Bi}=Ye,{initializeNode:zi}=Ne,{DEFAULT_VALUE:Fi,getNode:Wi}=_e,{copyTreeState:Ki,getRecoilValueAsLoadable:Gi,invalidateDownstreams:Hi,writeLoadableToTreeState:ji}=ge;function Ln(e){return Wi(e.key).nodeType==="atom"}class qi{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!Ln(o))throw D("Reading selectors within atomicUpdate is not supported");const r=Gi(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:D(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!Ln(o))throw D("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else zi(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Fi)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=Ki(this._treeState);for(const[n,o]of this._changes)ji(t,n,Bi(o));return Hi(this._store,t),t}}function Zi(e){return t=>{e.replaceState(n=>{const o=new qi(e,n);return t(o),o.newTreeState_INTERNAL()})}}var Yi={atomicUpdater:Zi},Xi=Yi.atomicUpdater,To=Object.freeze({__proto__:null,atomicUpdater:Xi});function Ji(e,t){if(!e)throw new Error(t)}var Qi=Ji,He=Qi;const{atomicUpdater:el}=To,{batchUpdates:tl}=en,{DEFAULT_VALUE:nl}=_e,{refreshRecoilValue:ol,setRecoilValue:Cn}=ge,{cloneSnapshot:rl}=gt,{gotoSnapshot:al}=Oi,{useCallback:Ac}=z;class Ao{}const sl=new Ao;function il(e,t,n,o){let r=sl,a;if(tl(()=>{const u="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw D(u);const d=qn({...o??{},set:(v,S)=>Cn(e,v,S),reset:v=>Cn(e,v,nl),refresh:v=>ol(e,v),gotoSnapshot:v=>al(e,v),transact_UNSTABLE:v=>el(e)(v)},{snapshot:()=>{const v=rl(e);return a=v.retain(),v}}),f=t(d);if(typeof f!="function")throw D(u);r=f(...n)}),r instanceof Ao&&He(!1),q(r))r=r.finally(()=>{var u;(u=a)===null||u===void 0||u()});else{var s;(s=a)===null||s===void 0||s()}return r}var ll={recoilCallback:il};const{useCallback:Nc}=z,{atomicUpdater:Lc}=To,{useMemo:Cc}=z;class cl{constructor(t){M(this,"value",void 0),this.value=t}}var ul={WrappedValue:cl},dl=ul.WrappedValue,No=Object.freeze({__proto__:null,WrappedValue:dl});class Vn extends Error{}class fl{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t==null?void 0:t.name,this._numLeafs=0,this._root=null,this._onHit=(n=t==null?void 0:t.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t==null?void 0:t.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t==null?void 0:t.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n==null||n.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,u,d;let f,v;for(const[Q,X]of t){var S,k,T;const w=this._root;if((w==null?void 0:w.type)==="leaf")throw this.invalidCacheError();const C=f;if(f=C?C.branches.get(v):w,f=(S=f)!==null&&S!==void 0?S:{type:"branch",nodeKey:Q,parent:C,branches:new Map,branchKey:v},f.type!=="branch"||f.nodeKey!==Q)throw this.invalidCacheError();C==null||C.branches.set(v,f),o==null||(k=o.onNodeVisit)===null||k===void 0||k.call(o,f),v=this._mapNodeValue(X),this._root=(T=this._root)!==null&&T!==void 0?T:f}const E=f?(a=f)===null||a===void 0?void 0:a.branches.get(v):this._root;if(E!=null&&(E.type!=="leaf"||E.branchKey!==v))throw this.invalidCacheError();const V={type:"leaf",value:n,parent:f,branchKey:v};(s=f)===null||s===void 0||s.branches.set(v,V),this._root=(u=this._root)!==null&&u!==void 0?u:V,this._numLeafs++,this._onSet(V),o==null||(d=o.onNodeVisit)===null||d===void 0||d.call(o,V)};try{r()}catch(a){if(a instanceof Vn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){throw ie("Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache."+(this._name!=null?` - ${this._name}`:"")),new Vn}}var hl={TreeCache:fl},vl=hl.TreeCache,Lo=Object.freeze({__proto__:null,TreeCache:vl});class pl{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=Y(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var _l={LRUCache:pl},ml=_l.LRUCache,Co=Object.freeze({__proto__:null,LRUCache:ml});const{LRUCache:yl}=Co,{TreeCache:Sl}=Lo;function gl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new yl({maxSize:t}),r=new Sl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var $n=gl;function ve(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if((t==null?void 0:t.allowFunctions)!==!0)throw D("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(q(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>ve(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return ve(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:ve(a,t)]=s;return ve(r,t,n)}return e instanceof Set?ve(Array.from(e).sort((r,a)=>ve(r,t).localeCompare(ve(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?ve(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${ve(r,t)}:${ve(e[r],t,r)}`).join(",")}}`}function bl(e,t={allowFunctions:!1}){return ve(e,t)}var rn=bl;const{TreeCache:Rl}=Lo,ot={equality:"reference",eviction:"keep-all",maxSize:1/0};function wl({equality:e=ot.equality,eviction:t=ot.eviction,maxSize:n=ot.maxSize}=ot,o){const r=El(e);return Tl(t,n,r,o)}function El(e){switch(e){case"reference":return t=>t;case"value":return t=>rn(t)}throw D(`Unrecognized equality policy ${e}`)}function Tl(e,t,n,o){switch(e){case"keep-all":return new Rl({name:o,mapNodeValue:n});case"lru":return $n({name:o,maxSize:Y(t),mapNodeValue:n});case"most-recent":return $n({name:o,maxSize:1,mapNodeValue:n})}throw D(`Unrecognized eviction policy ${e}`)}var Al=wl;const{isLoadable:Nl,loadableWithError:rt,loadableWithPromise:Ll,loadableWithValue:Dt}=Ye,{WrappedValue:Vo}=No,{getNodeLoadable:at,peekNodeLoadable:Cl,setNodeValue:Vl}=Ne,{saveDepsToStore:$l}=Je,{DEFAULT_VALUE:Ml,getConfigDeletionHandler:kl,getNode:Dl,registerNode:Mn}=_e,{isRecoilValue:Il}=Te,{markRecoilValueModified:kn}=ge,{retainedByOptionWithDefault:Ul}=Pe,{recoilCallback:Pl}=ll;class $o{}const We=new $o,Ke=[],st=new Map,xl=(()=>{let e=0;return()=>e++})();function Mo(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,u=Al(r??{equality:"reference",eviction:"keep-all"},n),d=Ul(e.retainedBy_UNSTABLE),f=new Map;let v=0;function S(){return!H("recoil_memory_managament_2020")||v>0}function k(c){return c.getState().knownSelectors.add(n),v++,()=>{v--}}function T(){return kl(n)!==void 0&&!S()}function E(c,p,_,$,b){de(p,$,b),V(c,_)}function V(c,p){le(c,p)&&J(c),X(p,!0)}function Q(c,p){le(c,p)&&(Y(ee(c)).stateVersions.clear(),X(p,!1))}function X(c,p){const _=st.get(c);if(_!=null){for(const $ of _)kn($,Y(t));p&&st.delete(c)}}function w(c,p){let _=st.get(p);_==null&&st.set(p,_=new Set),_.add(c)}function C(c,p,_,$,b,I){return p.then(R=>{if(!S())throw J(c),We;const O=Dt(R);return E(c,_,b,O,$),R}).catch(R=>{if(!S())throw J(c),We;if(q(R))return x(c,R,_,$,b,I);const O=rt(R);throw E(c,_,b,O,$),R})}function x(c,p,_,$,b,I){return p.then(R=>{if(!S())throw J(c),We;I.loadingDepKey!=null&&I.loadingDepPromise===p?_.atomValues.set(I.loadingDepKey,Dt(R)):c.getState().knownSelectors.forEach(B=>{_.atomValues.delete(B)});const O=G(c,_);if(O&&O.state!=="loading"){if((le(c,b)||ee(c)==null)&&V(c,b),O.state==="hasValue")return O.contents;throw O.contents}if(!le(c,b)){const B=ye(c,_);if(B!=null)return B.loadingLoadable.contents}const[j,te]=K(c,_,b);if(j.state!=="loading"&&E(c,_,b,j,te),j.state==="hasError")throw j.contents;return j.contents}).catch(R=>{if(R instanceof $o)throw We;if(!S())throw J(c),We;const O=rt(R);throw E(c,_,b,O,$),R})}function F(c,p,_,$){var b,I,R,O;if(le(c,$)||p.version===((b=c.getState())===null||b===void 0||(I=b.currentTree)===null||I===void 0?void 0:I.version)||p.version===((R=c.getState())===null||R===void 0||(O=R.nextTree)===null||O===void 0?void 0:O.version)){var j,te,B;$l(n,_,c,(j=(te=c.getState())===null||te===void 0||(B=te.nextTree)===null||B===void 0?void 0:B.version)!==null&&j!==void 0?j:c.getState().currentTree.version)}for(const ne of _)s.add(ne)}function K(c,p,_){let $=!0,b=!0;const I=()=>{b=!1};let R,O=!1,j;const te={loadingDepKey:null,loadingDepPromise:null},B=new Map;function ne({key:ce}){const ae=at(c,p,ce);switch(B.set(ce,ae),$||(F(c,p,new Set(B.keys()),_),Q(c,_)),ae.state){case"hasValue":return ae.contents;case"hasError":throw ae.contents;case"loading":throw te.loadingDepKey=ce,te.loadingDepPromise=ae.contents,ae.contents}throw D("Invalid Loadable state")}const me=ce=>(...ae)=>{if(b)throw D("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&He(!1),Pl(c,ce,ae,{node:t})};try{R=o({get:ne,getCallback:me}),R=Il(R)?ne(R):R,Nl(R)&&(R.state==="hasError"&&(O=!0),R=R.contents),q(R)?R=C(c,R,p,B,_,te).finally(I):I(),R=R instanceof Vo?R.value:R}catch(ce){R=ce,q(R)?R=x(c,R,p,B,_,te).finally(I):(O=!0,I())}return O?j=rt(R):q(R)?j=Ll(R):j=Dt(R),$=!1,Ce(c,_,B),F(c,p,new Set(B.keys()),_),[j,B]}function G(c,p){let _=p.atomValues.get(n);if(_!=null)return _;const $=new Set;try{_=u.get(I=>(typeof I!="string"&&He(!1),at(c,p,I).contents),{onNodeVisit:I=>{I.type==="branch"&&I.nodeKey!==n&&$.add(I.nodeKey)}})}catch(I){throw D(`Problem with cache lookup for selector "${n}": ${I.message}`)}if(_){var b;p.atomValues.set(n,_),F(c,p,$,(b=ee(c))===null||b===void 0?void 0:b.executionID)}return _}function re(c,p){const _=G(c,p);if(_!=null)return J(c),_;const $=ye(c,p);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&w(c,$.executionID),$.loadingLoadable}const I=xl(),[R,O]=K(c,p,I);return R.state==="loading"?(ue(c,I,R,O,p),w(c,I)):(J(c),de(p,R,O)),R}function ye(c,p){const _=uo([f.has(c)?[Y(f.get(c))]:[],pt(Xt(f,([b])=>b!==c),([,b])=>b)]);function $(b){for(const[I,R]of b)if(!at(c,p,I).is(R))return!0;return!1}for(const b of _){if(b.stateVersions.get(p.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(p.version,!0),b;b.stateVersions.set(p.version,!1)}}function ee(c){return f.get(c)}function ue(c,p,_,$,b){f.set(c,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:p,loadingLoadable:_,stateVersions:new Map([[b.version,!0]])})}function Ce(c,p,_){if(le(c,p)){const $=ee(c);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=_)}}function J(c){f.delete(c)}function le(c,p){var _;return p===((_=ee(c))===null||_===void 0?void 0:_.executionID)}function Re(c){return Array.from(c.entries()).map(([p,_])=>[p,_.contents])}function de(c,p,_){c.atomValues.set(n,p);try{u.set(Re(_),p)}catch($){throw D(`Problem with setting cache for selector "${n}": ${$.message}`)}}function Se(c){if(Ke.includes(n)){const p=`Recoil selector has circular dependencies: ${Ke.slice(Ke.indexOf(n)).join("  ")}`;return rt(D(p))}Ke.push(n);try{return c()}finally{Ke.pop()}}function Ve(c,p){const _=p.atomValues.get(n);return _??u.get($=>{var b;return typeof $!="string"&&He(!1),(b=Cl(c,p,$))===null||b===void 0?void 0:b.contents})}function $e(c,p){return Se(()=>re(c,p))}function P(c){c.atomValues.delete(n)}function W(c,p){t==null&&He(!1);for(const $ of s){var _;const b=Dl($);(_=b.clearCache)===null||_===void 0||_.call(b,c,p)}s.clear(),P(p),u.clear(),kn(c,t)}return a!=null?t=Mn({key:n,nodeType:"selector",peek:Ve,get:$e,set:(p,_,$)=>{let b=!1;const I=new Map;function R({key:B}){if(b)throw D("Recoil: Async selector sets are not currently supported.");const ne=at(p,_,B);if(ne.state==="hasValue")return ne.contents;if(ne.state==="loading"){const me=`Getting value of asynchronous atom or selector "${B}" in a pending state while setting selector "${n}" is not yet supported.`;throw ie(),D(me)}else throw ne.contents}function O(B,ne){if(b){const ae="Recoil: Async selector sets are not currently supported.";throw ie(),D(ae)}const me=typeof ne=="function"?ne(R(B)):ne;Vl(p,_,B.key,me).forEach((ae,tt)=>I.set(tt,ae))}function j(B){O(B,Ml)}const te=a({set:O,get:R,reset:j},$);if(te!==void 0)throw q(te)?D("Recoil: Async selector sets are not currently supported."):D("Recoil: selector set should be a void function.");return b=!0,I},init:k,invalidate:P,clearCache:W,shouldDeleteConfigOnRelease:T,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d}):t=Mn({key:n,nodeType:"selector",peek:Ve,get:$e,init:k,invalidate:P,clearCache:W,shouldDeleteConfigOnRelease:T,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}Mo.value=e=>new Vo(e);var qe=Mo;const{isLoadable:Ol,loadableWithError:It,loadableWithPromise:Ut,loadableWithValue:ke}=Ye,{WrappedValue:ko}=No,{peekNodeInfo:Bl}=Ne,{DEFAULT_VALUE:we,DefaultValue:be,getConfigDeletionHandler:Do,registerNode:zl,setConfigDeletionHandler:Fl}=_e,{isRecoilValue:Wl}=Te,{getRecoilValueAsLoadable:Kl,markRecoilValueModified:Gl,setRecoilValue:Dn,setRecoilValueLoadable:Hl}=ge,{retainedByOptionWithDefault:jl}=Pe,Ge=e=>e instanceof ko?e.value:e;function ql(e){const{key:t,persistence_UNSTABLE:n}=e,o=jl(e.retainedBy_UNSTABLE);let r=0;function a(w){return Ut(w.then(C=>(s=ke(C),C)).catch(C=>{throw s=It(C),C}))}let s=q(e.default)?a(e.default):Ol(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:ke(Ge(e.default));s.contents;let u;const d=new Map;function f(w){return w}function v(w,C){const x=C.then(F=>{var K,G;return((G=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||G===void 0?void 0:G.contents)===x&&Dn(w,X,F),F}).catch(F=>{var K,G;throw((G=((K=w.getState().nextTree)!==null&&K!==void 0?K:w.getState().currentTree).atomValues.get(t))===null||G===void 0?void 0:G.contents)===x&&Hl(w,X,It(F)),F});return x}function S(w,C,x){var F;r++;const K=()=>{var ee;r--,(ee=d.get(w))===null||ee===void 0||ee.forEach(ue=>ue()),d.delete(w)};if(w.getState().knownAtoms.add(t),s.state==="loading"){const ee=()=>{var ue;((ue=w.getState().nextTree)!==null&&ue!==void 0?ue:w.getState().currentTree).atomValues.has(t)||Gl(w,X)};s.contents.finally(ee)}const G=(F=e.effects)!==null&&F!==void 0?F:e.effects_UNSTABLE;if(G!=null){let ee=function(P){if(le&&P.key===t){const W=J;return W instanceof be?k(w,C):q(W)?Ut(W.then(c=>c instanceof be?s.toPromise():c)):ke(W)}return Kl(w,P)},ue=function(P){return ee(P).toPromise()},Ce=function(P){var W;const c=Bl(w,(W=w.getState().nextTree)!==null&&W!==void 0?W:w.getState().currentTree,P.key);return le&&P.key===t&&!(J instanceof be)?{...c,isSet:!0,loadable:ee(P)}:c},J=we,le=!0,Re=!1,de=null;const Se=P=>W=>{if(le){const c=ee(X),p=c.state==="hasValue"?c.contents:we;J=typeof W=="function"?W(p):W,q(J)&&(J=J.then(_=>(de={effect:P,value:_},_)))}else{if(q(W))throw D("Setting atoms to async values is not implemented.");typeof W!="function"&&(de={effect:P,value:Ge(W)}),Dn(w,X,typeof W=="function"?c=>{const p=Ge(W(c));return de={effect:P,value:p},p}:Ge(W))}},Ve=P=>()=>Se(P)(we),$e=P=>W=>{var c;const{release:p}=w.subscribeToTransactions(_=>{var $;let{currentTree:b,previousTree:I}=_.getState();I||(ie(),I=b);const R=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(R.state==="hasValue"){var O,j,te,B;const ne=R.contents,me=(O=I.atomValues.get(t))!==null&&O!==void 0?O:s,ce=me.state==="hasValue"?me.contents:we;((j=de)===null||j===void 0?void 0:j.effect)!==P||((te=de)===null||te===void 0?void 0:te.value)!==ne?W(ne,ce,!b.atomValues.has(t)):((B=de)===null||B===void 0?void 0:B.effect)===P&&(de=null)}},t);d.set(w,[...(c=d.get(w))!==null&&c!==void 0?c:[],p])};for(const P of G)try{const W=P({node:X,storeID:w.storeID,parentStoreID_UNSTABLE:w.parentStoreID,trigger:x,setSelf:Se(P),resetSelf:Ve(P),onSet:$e(P),getPromise:ue,getLoadable:ee,getInfo_UNSTABLE:Ce});if(W!=null){var re;d.set(w,[...(re=d.get(w))!==null&&re!==void 0?re:[],W])}}catch(W){J=W,Re=!0}if(le=!1,!(J instanceof be)){var ye;const P=Re?It(J):q(J)?Ut(v(w,J)):ke(Ge(J));P.contents,C.atomValues.set(t,P),(ye=w.getState().nextTree)===null||ye===void 0||ye.atomValues.set(t,P)}}return K}function k(w,C){var x,F;return(x=(F=C.atomValues.get(t))!==null&&F!==void 0?F:u)!==null&&x!==void 0?x:s}function T(w,C){if(C.atomValues.has(t))return Y(C.atomValues.get(t));if(C.nonvalidatedAtoms.has(t)){if(u!=null)return u;if(n==null)return Wn(),s;const x=C.nonvalidatedAtoms.get(t),F=n.validator(x,we);return u=F instanceof be?s:ke(F),u}else return s}function E(){u=void 0}function V(w,C,x){if(C.atomValues.has(t)){const F=Y(C.atomValues.get(t));if(F.state==="hasValue"&&x===F.contents)return new Map}else if(!C.nonvalidatedAtoms.has(t)&&x instanceof be)return new Map;return u=void 0,new Map().set(t,ke(x))}function Q(){return Do(t)!==void 0&&r<=0}const X=zl({key:t,nodeType:"atom",peek:k,get:T,set:V,init:S,invalidate:E,shouldDeleteConfigOnRelease:Q,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return X}function an(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return Wl(n)?Zl({...t,default:n}):ql({...t,default:n})}function Zl(e){const t=an({...e,default:we,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:Y(e.persistence_UNSTABLE).validator(o,we)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=qe({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return Fl(n.key,Do(e.key)),n}an.value=e=>new ko(e);var Yl=an;class Xl{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t==null?void 0:t.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var Jl={MapCache:Xl},Ql=Jl.MapCache,ec=Object.freeze({__proto__:null,MapCache:Ql});const{LRUCache:In}=Co,{MapCache:tc}=ec,it={equality:"reference",eviction:"none",maxSize:1/0};function nc({equality:e=it.equality,eviction:t=it.eviction,maxSize:n=it.maxSize}=it){const o=oc(e);return rc(t,n,o)}function oc(e){switch(e){case"reference":return t=>t;case"value":return t=>rn(t)}throw D(`Unrecognized equality policy ${e}`)}function rc(e,t,n){switch(e){case"keep-all":return new tc({mapKey:n});case"lru":return new In({mapKey:n,maxSize:Y(t)});case"most-recent":return new In({mapKey:n,maxSize:1})}throw D(`Unrecognized eviction policy ${e}`)}var ac=nc;const{setConfigDeletionHandler:sc}=_e;let ic=0;function lc(e){var t,n;const o=ac({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(k){throw D(`Problem with cache lookup for selector ${e.key}: ${k.message}`)}if(s!=null)return s;const u=`${e.key}__selectorFamily/${(a=rn(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${ic++}`,d=k=>e.get(r)(k),f=e.cachePolicy_UNSTABLE,v=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let S;if(e.set!=null){const k=e.set;S=qe({key:u,get:d,set:(E,V)=>k(r)(E,V),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v})}else S=qe({key:u,get:d,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:v});return o.set(r,S),sc(S.key,()=>{o.delete(r)}),S}}var Le=lc;Le({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});Le({key:"__error",get:e=>()=>{throw D(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});const{loadableWithError:Io,loadableWithPromise:Uo,loadableWithValue:Po}=Ye;function Et(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function cc(e){return e!=null&&!q(e)}function Tt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function Wt(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function De(e,t,n){const o=n.map((r,a)=>r==null?Po(t[a]):q(r)?Uo(r):Io(r));return Wt(e,o)}function uc(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}Le({key:"__waitForNone",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return De(e,o,r)},dangerouslyAllowMutability:!0});Le({key:"__waitForAny",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.some(a=>!q(a))?De(e,o,r):new Promise(a=>{for(const[s,u]of r.entries())q(u)&&u.then(d=>{o[s]=d,r[s]=void 0,a(De(e,o,r))}).catch(d=>{r[s]=d,a(De(e,o,r))})})},dangerouslyAllowMutability:!0});Le({key:"__waitForAll",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);if(r.every(s=>s==null))return Wt(e,o);const a=r.find(cc);if(a!=null)throw a;return Promise.all(r).then(s=>Wt(e,uc(o,s)))},dangerouslyAllowMutability:!0});Le({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=Tt(e),[o,r]=Et(t,n);return r.every(a=>!q(a))?De(e,o,r):Promise.all(r.map((a,s)=>q(a)?a.then(u=>{o[s]=u,r[s]=void 0}).catch(u=>{o[s]=void 0,r[s]=u}):null)).then(()=>De(e,o,r))},dangerouslyAllowMutability:!0});Le({key:"__noWait",get:e=>({get:t})=>{try{return qe.value(Po(t(e)))}catch(n){return qe.value(q(n)?Uo(n):Io(n))}},dangerouslyAllowMutability:!0});const{RecoilLoadable:Vc}=Ye,{RecoilRoot:dc}=on,{isRecoilValue:$c}=Te,{freshSnapshot:Mc}=gt,{useRecoilState:fc}=Mi;var sn={RecoilRoot:dc,atom:Yl,useRecoilState:fc},kc=sn.RecoilRoot,Dc=sn.atom,Ic=sn.useRecoilState;const hc=z.createContext({}),xo=!0;function vc({baseColor:e,highlightColor:t,width:n,height:o,borderRadius:r,circle:a,direction:s,duration:u,enableAnimation:d=xo,customHighlightBackground:f}){const v={};return s==="rtl"&&(v["--animation-direction"]="reverse"),typeof u=="number"&&(v["--animation-duration"]=`${u}s`),d||(v["--pseudo-element-display"]="none"),(typeof n=="string"||typeof n=="number")&&(v.width=n),(typeof o=="string"||typeof o=="number")&&(v.height=o),(typeof r=="string"||typeof r=="number")&&(v.borderRadius=r),a&&(v.borderRadius="50%"),typeof e<"u"&&(v["--base-color"]=e),typeof t<"u"&&(v["--highlight-color"]=t),typeof f=="string"&&(v["--custom-highlight-background"]=f),v}function Uc({count:e=1,wrapper:t,className:n,containerClassName:o,containerTestId:r,circle:a=!1,style:s,...u}){var d,f,v;const S=z.useContext(hc),k={...u};for(const[C,x]of Object.entries(u))typeof x>"u"&&delete k[C];const T={...S,...k,circle:a},E={...s,...vc(T)};let V="react-loading-skeleton";n&&(V+=` ${n}`);const Q=(d=T.inline)!==null&&d!==void 0?d:!1,X=[],w=Math.ceil(e);for(let C=0;C<w;C++){let x=E;if(w>e&&C===w-1){const K=(f=x.width)!==null&&f!==void 0?f:"100%",G=e%1,re=typeof K=="number"?K*G:`calc(${K} * ${G})`;x={...x,width:re}}const F=z.createElement("span",{className:V,style:x,key:C},"");Q?X.push(F):X.push(z.createElement(z.Fragment,{key:C},F,z.createElement("br",null)))}return z.createElement("span",{className:o,"data-testid":r,"aria-live":"polite","aria-busy":(v=T.enableAnimation)!==null&&v!==void 0?v:xo},t?X.map((C,x)=>z.createElement(t,{key:x},C)):X)}export{Dc as R,Uc as S,Ic as a,kc as b};
